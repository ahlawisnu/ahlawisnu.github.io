<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clash Provider Converter — vmess/vless/trojan → Clash</title>
  <style>
    :root{--bg:#f7fafc;--card:#fff;--muted:#475569;--accent:#0ea5e9;--dark:#0f172a}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans',Arial;background:var(--bg);color:var(--dark);padding:20px}
    .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 6px 18px rgba(15,23,42,0.06);max-width:980px;margin:auto}
    h1{font-size:1.25rem;margin:0 0 8px}
    p{margin:0 0 12px;color:var(--muted)}
    textarea{width:100%;height:160px;padding:12px;border-radius:8px;border:1px solid #e2e8f0;background:var(--card);resize:vertical}
    .row{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
    .col{flex:1}
    button{background:var(--accent);border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer}
    button.secondary{background:#64748b}
    pre{background:var(--dark);color:#e6eef8;padding:12px;border-radius:8px;overflow:auto;white-space:pre-wrap}
    small{color:var(--muted)}
    label{display:block;margin-bottom:6px;font-weight:600}
    .controls{display:flex;gap:8px;align-items:center}
    .status{margin-left:8px;color:var(--muted);font-size:0.95rem}
    .toast{position:fixed;right:20px;bottom:20px;background:#111827;color:white;padding:10px 14px;border-radius:8px;box-shadow:0 6px 18px rgba(2,6,23,0.5);opacity:0;transform:translateY(8px);transition:all .22s}
    .toast.show{opacity:1;transform:translateY(0)}
    .note{font-size:0.9rem;color:var(--muted);margin-top:8px}
    input[type="checkbox"]{margin-right:6px}
  </style>
</head>
<body>
  <div class="card">
    <h1>Clash Provider Converter</h1>
    <p>Tempel <strong>vmess://</strong>, <strong>vless://</strong> atau <strong>trojan://</strong> — satu per baris. Klik <em>Convert</em> untuk menghasilkan snippet YAML bagian <code>proxies:</code> yang kompatibel dengan Clash.</p>

    <label for="input">Input — vmess / vless / trojan (multiple lines OK):</label>
    <textarea id="input" placeholder="Contoh: vmess://base64...\nvless://...#nama-server\ntrojan://pass@host:port#nama"></textarea>

    <div class="row" style="margin-top:10px;align-items:center">
      <div style="flex:1;display:flex;gap:8px;flex-wrap:wrap">
        <div class="controls">
          <button id="convert">Convert</button>
          <button id="copy" class="secondary">Copy YAML</button>
          <button id="download" class="secondary">Download .yaml</button>
        </div>
        <div style="display:flex;align-items:center;margin-left:8px">
          <small class="status" id="status">Siap</small>
        </div>
      </div>
      <div style="text-align:right">
        <small>Periksa kembali field TLS / ws-path / headers setelah konversi.</small>
      </div>
    </div>

    <h3 style="margin-top:18px">Output (YAML)</h3>
    <pre id="output"># Tekan Convert untuk menghasilkan YAML proxies...</pre>
    <div class="note">Catatan: Hasil otomatis dibuat sesuai format Clash dasar. Untuk subscribe atau export provider lengkap, minta fitur tambahan.</div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
    // small helper toast
    function showToast(msg, timeout=2500){
      const t = document.getElementById('toast');
      t.textContent = msg; t.classList.add('show');
      clearTimeout(t._to);
      t._to = setTimeout(()=> t.classList.remove('show'), timeout);
    }

    // util: decode base64 with URL-safe support
    function safeAtob(input){
      try{
        input = input.replace(/\s+/g, '');
        input = input.replace(/-/g, '+').replace(/_/g, '/');
        while(input.length % 4) input += '=';
        return atob(input);
      }catch(e){
        return null;
      }
    }

    function parseVmess(uri){
      let payload = uri.replace(/^vmess:\/\//i,'');
      let jsonText = null;
      // try base64
      let dec = safeAtob(payload);
      if(dec){
        try{ JSON.parse(dec); jsonText = dec; } catch(e){ jsonText = null; }
      }
      // fallback: maybe direct JSON
      if(!jsonText){
        try{ JSON.parse(payload); jsonText = payload; } catch(e){ jsonText = null; }
      }
      if(!jsonText) return null;
      try{
        let j = JSON.parse(jsonText);
        return {
          name: j.ps || j.tag || (j.add? (j.add+':'+j.port):'vmess'),
          type: 'vmess',
          server: j.add || j.host || '',
          port: Number(j.port || 0),
          uuid: j.id || j.uuid || j.psw || '',
          alterId: Number(j.aid || j.alterId || 0),
          cipher: j.scy || j.cipher || 'auto',
          tls: (j.tls==='tls' || (j.tls===true)),
          network: j.net || j.type || '',
          'ws-opts': {
            path: j.path || j.wspath || '',
            headers: j.host? {'Host': j.host} : {}
          }
        };
      }catch(e){ return null; }
    }

    function parseVless(uri){
      try{
        let u = uri.replace(/^vless:\/\//i,'');
        let name = '';
        let hashIdx = u.indexOf('#');
        if(hashIdx>=0){ name = decodeURIComponent(u.slice(hashIdx+1)); u = u.slice(0,hashIdx); }
        let qIdx = u.indexOf('?');
        let q = '';
        if(qIdx>=0){ q = u.slice(qIdx+1); u = u.slice(0,qIdx); }
        // now u = uuid@host:port
        let lastAt = u.lastIndexOf('@');
        if(lastAt < 0) return null;
        let userHost = u.slice(0); // keep full
        let [left, portRaw] = u.split(':');
        let port = Number(portRaw||0);
        let uuid = u.slice(0,lastAt).split('@')[0];
        // safer parse: split by @ then last ':' for port
        let afterAt = u.slice(lastAt+1);
        let host = afterAt.split(':')[0] || '';
        let params = {};
        if(q){ q.split('&').forEach(p=>{ let kv=p.split('='); params[kv[0]] = kv[1]||''; }); }
        let tls = (params.tls === 'tls' || params.security === 'tls');
        return {
          name: name || host+':' + port,
          type: 'vless',
          server: host,
          port: port,
          uuid: uuid,
          cipher: 'none',
          tls: !!tls,
          network: params.type || params.net || '',
          'ws-opts': { path: params.path || params['ws-path'] || '', headers: (params.host? {'Host': decodeURIComponent(params.host)}:{}) }
        };
      }catch(e){return null;}
    }

    function parseTrojan(uri){
      try{
        let u = uri.replace(/^trojan:\/\//i,'');
        let name = '';
        let hashIdx = u.indexOf('#');
        if(hashIdx>=0){ name = decodeURIComponent(u.slice(hashIdx+1)); u = u.slice(0,hashIdx); }
        let qIdx = u.indexOf('?');
        let q = '';
        if(qIdx>=0){ q = u.slice(qIdx+1); u = u.slice(0,qIdx); }
        let at = u.indexOf('@');
        if(at < 0) return null;
        let password = u.slice(0,at);
        let hostport = u.slice(at+1);
        let [host, portRaw] = hostport.split(':');
        let port = Number(portRaw||0);
        let params = {};
        if(q){ q.split('&').forEach(p=>{ let kv=p.split('='); params[kv[0]] = kv[1]||''; }); }
        let sni = params.sni? decodeURIComponent(params.sni) : undefined;
        return {
          name: name || host+':'+port,
          type: 'trojan',
          server: host,
          port: port,
          password: password,
          sni: sni,
          tls: (params.security==='tls' || params.tls==='tls')
        };
      }catch(e){return null;}
    }

    function toYAML(proxies){
      let lines = [];
      lines.push('proxies:');
      proxies.forEach(p=>{
        const safe = s => String(s||'').replace(/"/g,'\"');
        lines.push('  - name: "' + safe(p.name) + '"');
        lines.push('    type: ' + p.type);
        lines.push('    server: ' + (p.server || ''));
        lines.push('    port: ' + (p.port || 0));
        if(p.type==='vmess'){
          lines.push('    uuid: ' + (p.uuid || ''));
          if(p.alterId !== undefined) lines.push('    alterId: ' + (p.alterId || 0));
          lines.push('    cipher: ' + (p.cipher || 'auto'));
          if(p.tls) lines.push('    tls: true');
          if(p.network) lines.push('    network: ' + p.network);
          if(p['ws-opts'] && (p['ws-opts'].path || (p['ws-opts'].headers && Object.keys(p['ws-opts'].headers).length))){
            lines.push('    ws-opts:');
            if(p['ws-opts'].path) lines.push('      path: "' + safe(p['ws-opts'].path) + '"');
            if(p['ws-opts'].headers && Object.keys(p['ws-opts'].headers).length){
              lines.push('      headers:');
              for(let k in p['ws-opts'].headers){ lines.push('        ' + k + ': "' + safe(p['ws-opts'].headers[k]) + '"'); }
            }
          }
        } else if(p.type==='vless'){
          lines.push('    uuid: ' + (p.uuid || ''));
          if(p.tls) lines.push('    tls: true');
          if(p.network) lines.push('    network: ' + p.network);
          if(p['ws-opts'] && (p['ws-opts'].path || (p['ws-opts'].headers && Object.keys(p['ws-opts'].headers).length))){
            lines.push('    ws-opts:');
            if(p['ws-opts'].path) lines.push('      path: "' + safe(p['ws-opts'].path) + '"');
            if(p['ws-opts'].headers && Object.keys(p['ws-opts'].headers).length){
              lines.push('      headers:');
              for(let k in p['ws-opts'].headers){ lines.push('        ' + k + ': "' + safe(p['ws-opts'].headers[k]) + '"'); }
            }
          }
        } else if(p.type==='trojan'){
          lines.push('    password: "' + safe(p.password) + '"');
          if(p.sni) lines.push('    sni: "' + safe(p.sni) + '"');
          if(p.tls) lines.push('    tls: true');
        }
      });
      return lines.join('\n');
    }

    const inputEl = document.getElementById('input');
    const outputEl = document.getElementById('output');
    const statusEl = document.getElementById('status');

    document.getElementById('convert').addEventListener('click', ()=>{
      statusEl.textContent = 'Memproses...';
      const text = inputEl.value.trim();
      if(!text){ outputEl.textContent = '# Masukkan konfigurasi vmess/vless/trojan terlebih dahulu.'; statusEl.textContent = 'Kosong'; showToast('Masukkan input terlebih dahulu'); return; }
      const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      const proxies = [];
      lines.forEach(line=>{
        if(line.startsWith('vmess://')){
          let p = parseVmess(line);
          if(p) proxies.push(p);
          else proxies.push({name: line.slice(8,40), type:'vmess', server:'', port:0});
        } else if(line.startsWith('vless://')){
          let p = parseVless(line);
          if(p) proxies.push(p);
          else proxies.push({name:'vless',type:'vless',server:'',port:0});
        } else if(line.startsWith('trojan://')){
          let p = parseTrojan(line);
          if(p) proxies.push(p);
          else proxies.push({name:'trojan',type:'trojan',server:'',port:0});
        } else {
          // ignore unknown/blank lines
        }
      });
      const yaml = toYAML(proxies);
      outputEl.textContent = yaml;
      statusEl.textContent = 'Selesai (' + proxies.length + ' proxy)';
      showToast('Convert selesai');
    });

    // Robust copy function: try Clipboard API, fallback to execCommand
    async function copyToClipboard(text){
      if(!text) throw new Error('Tidak ada teks untuk disalin');
      // primary: navigator.clipboard
      if(navigator.clipboard && navigator.clipboard.writeText){
        try{ await navigator.clipboard.writeText(text); return true; } catch(e){ /* fallback below */ }
      }
      // fallback: hidden textarea + execCommand
      const ta = document.createElement('textarea');
      ta.value = text;
      // avoid scrolling to bottom
      ta.style.position = 'fixed'; ta.style.left = '-9999px'; ta.style.top = '0';
      document.body.appendChild(ta);
      ta.focus(); ta.select();
      try{
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        if(!ok) throw new Error('execCommand failed');
        return true;
      }catch(e){
        document.body.removeChild(ta);
        throw e;
      }
    }

    document.getElementById('copy').addEventListener('click', async ()=>{
      const out = outputEl.textContent || '';
      if(!out || out.trim().length===0){ showToast('Tidak ada output untuk disalin'); statusEl.textContent = 'Kosong'; return; }
      try{
        await copyToClipboard(out);
        showToast('YAML berhasil disalin ke clipboard');
        statusEl.textContent = 'Disalin';
      }catch(e){
        showToast('Gagal menyalin ke clipboard — coba download');
        statusEl.textContent = 'Gagal menyalin';
      }
    });

    document.getElementById('download').addEventListener('click', ()=>{
      const out = outputEl.textContent || '';
      if(!out || out.trim().length===0){ showToast('Tidak ada output untuk didownload'); return; }
      const blob = new Blob([out], {type:'text/yaml'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'clash-proxies.yaml';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      showToast('File YAML didownload');
    });

    // keyboard shortcut: Ctrl/Cmd+Enter = convert
    document.addEventListener('keydown', (e)=>{
      if((e.ctrlKey||e.metaKey) && e.key === 'Enter'){
        document.getElementById('convert').click();
      }
    });

    // Improve UX: paste example when double-clicking output
    outputEl.addEventListener('dblclick', ()=>{
      const t = outputEl.textContent || '';
      if(t && t.includes('proxies:')){
        // try to copy quickly
        copyToClipboard(t).then(()=> showToast('Output disalin')).catch(()=>{});
      }
    });
  </script>

  <!--
    Versi lengkap: perbaikan tombol Copy (Clipboard API + fallback), status/feedback, dan UI sedikit ditingkatkan.
    Jika mau: dukungan parse subscription (URL yang mengandung banyak link), export ke `providers:`, atau validasi lebih ketat,
    bilang saja dan aku tambahkan.
  -->
</body>
</html>
